{-# OPTIONS --without-K --rewriting #-}

open import HoTT
open import Monad
open import MonadOver
open import Pb
open import OpetopicType
-- open import IdentityMonad
-- open import IdentityMonadOver
-- open import InftyGroupoid
-- open import FundamentalThm
-- open import MonadEqv 
open import SliceUnfold

module SlcUnique where

  --
  --  Investigating the consequences of fibrancy ... 
  --
  module _ (M : ùïÑ) (M‚Üì : ùïÑ‚Üì M) where

    open Slices M M‚Üì 

    module _ (R : Idx Slc‚ÇÇ ‚Üí Set) where

      SlcR : ùïÑ
      SlcR = Slice (Pb Slc‚ÇÇ R)

      module _ (T : Idx SlcR ‚Üí Set) (is-fib-T : unique-action Slc‚ÇÇ R T) where

        -- So, what does the fibrancy of T get us in this case?
        dbl-slice-unit : (i : Idx M) (j : Idx‚Üì M‚Üì i) ‚Üí Idx Slc‚ÇÇ
        dbl-slice-unit i j = (((i , j) , (_ , _)) , ((j , idp) , (Œ∑‚Üì M‚Üì j , cst idp))) , lf (i , j) , Œª { () }

        -- Ahh!  What's the unit?
        T-lf : (i : Idx (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ))) ‚Üí Cns Slc‚ÇÇ (i , Œ∑ (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ)) i)
        T-lf i = lf i 

        R-unital : (i : Idx (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ))) ‚Üí R (i , Œ∑ (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ)) i) 
        R-unital i = fst (contr-center (is-fib-T (i , Œ∑ (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ)) i) (lf i) (Œª { () })))

        gen-case : Idx (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ)) ‚Üí Type‚ÇÄ
        gen-case (((i , j) , (c , ŒΩ)) , ((j' , j'=j) , d , typ-d=ŒΩ)) = {!Œ∑ (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ)) (((i , j) , (c , ŒΩ)) , ((j' , j'=j) , d , typ-d=ŒΩ))!} 

        -- nd (c , ŒΩ) (Œª p ‚Üí Œ∑ M (Typ M c p) , (Œª _ ‚Üí ŒΩ p)) (Œª p ‚Üí lf (Typ M c p , ŒΩ p)), (Œª _ ‚Üí (j' , j'=j) , d , typ-d=ŒΩ)

        idx-pb : (i : Idx M) (j : Idx‚Üì M‚Üì i) ‚Üí Idx (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ))
        idx-pb i j = (((i , j) , (_ , _)) , ((j , idp) , (Œ∑‚Üì M‚Üì j , cst idp)))

        eta-pb : (i : Idx M) (j : Idx‚Üì M‚Üì i) ‚Üí Cns (Pb Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ)) (idx-pb i j)
        eta-pb i j = nd (Œ∑ M i , (Œª _ ‚Üí j)) (Œª _ ‚Üí Œ∑ M i , (Œª _ ‚Üí j)) (Œª _ ‚Üí lf (i , j)) , Œª { true ‚Üí (j , idp) , (Œ∑‚Üì M‚Üì j , cst idp) } 

        -- Hmmm.  This doesn't typecheck when we actually normalize.  Is that kind
        -- of thing a problem?
        
        special-case : (i : Idx M) (j : Idx‚Üì M‚Üì i) ‚Üí R (idx-pb i j , {!eta-pb i j!})
        special-case i j = R-unital (((i , j) , (_ , _)) , ((j , idp) , (Œ∑‚Üì M‚Üì j , cst idp))) 

        -- Okay.  So. This indeed shows that these are *not* the
        -- hypotheses that we see below.  Yes, exactly!  Under the
        -- identification of R with the canonical relation, we should
        -- see that in the next step, this kind of "unit construction"
        -- *becomes* the unit over, and that's why we have an
        -- inhabitant of relating it to a leaf.

        -- So I think I agree that your prediction is right: we do
        -- indeed need these extra hypotheses on R, and under the the
        -- identification of R with the canonical relation, T should
        -- be transformed to a relation which satisfies exactly these
        -- same principles.
        
  module _ (M : ùïÑ) (M‚Üì : ùïÑ‚Üì M) (is-alg : is-algebraic M M‚Üì) where

    open Slices M M‚Üì
    
    module _ (R : Idx Slc‚ÇÇ ‚Üí Set) (is-fib-R : unique-action Slc‚ÇÅ (Idx‚Üì Slc‚Üì‚ÇÅ) R) where

      -- Wait, can I *prove* the statement below using the fibrancy of R? 

      module _ (i : Idx M) (j : Idx‚Üì M‚Üì i) where

        ctr : Œ£ (Idx‚Üì Slc‚Üì‚ÇÅ ((i , j) , (Œ∑ M i , cst j))) (Œª z ‚Üí R ((((i , j) , (Œ∑ M i , cst j)) , z) , lf (i , j) , ‚ä•-elim))
        ctr = contr-center (is-fib-R ((i , j) , (Œ∑ M i , cst j)) (lf (i , j)) ‚ä•-elim)

        R-fib-lf : R ((((i , j) , (Œ∑ M i , cst j)) , fst ctr) , lf (i , j) , ‚ä•-elim)
        R-fib-lf = snd ctr 

        -- So I think the point is that the contraction center gives you these *four* pieces of data.
        -- That's why the fibration needs the extra agrument here.  But that's should be okay, you can
        -- still transport along the contractible piece.
        Alg-Fib : (Œ± : alg-comp M M‚Üì i (Œ∑ M i) (cst j)) (p : idx Œ± == j)  ‚Üí Set
        Alg-Fib ‚ü¶ idx ‚à£ cns ‚à£ typ ‚üß p = R ((((i , j) , (Œ∑ M i , cst j)) , (idx , p) , (cns , app= typ)) , lf (i , j) , ‚ä•-elim)

        -- Is this going to be enough to map to and from the canonical
        -- relation?  I see.  So the question is going to be if, there
        -- is actually a path from this guy to the canonical guy *in
        -- the space of four tuples*.  You get the first three from
        -- the algebricity of the extension.  The path over will be a
        -- commutative triangle, right?  But you will be using the
        -- *identity* path, so I think it will work out!

        canon-alg : alg-comp M M‚Üì i (Œ∑ M i) (cst j)
        canon-alg = ‚ü¶ j ‚à£ Œ∑‚Üì M‚Üì j ‚à£ idp ‚üß 
      
        r-alg : alg-comp M M‚Üì i (Œ∑ M i) (cst j)
        r-alg = ‚ü¶ fst (fst (fst ctr)) ‚à£ fst (snd (fst ctr)) ‚à£ Œª= (snd (snd (fst ctr))) ‚üß 

        by-alg : r-alg == canon-alg
        by-alg = contr-has-all-paths ‚¶É is-alg i (Œ∑ M i) (cst j) ‚¶Ñ r-alg canon-alg

        triangle : snd (fst (fst ctr)) == idp [ (Œª Œ± ‚Üí idx Œ± == j) ‚Üì by-alg ]
        triangle = ‚Üì-app=cst-in {!snd (fst (fst ctr))!}

        do-we-have : (j , idp) == (fst (fst ctr)) 
        do-we-have = {!!}

      module _ (i : Idx M) 
          (c : Cns M i) (ŒΩ : (p : Pos M c) ‚Üí Idx‚Üì M‚Üì (Typ M c p))
          (Œ¥ : (p : Pos M c) ‚Üí Cns‚Çö M (Œª z ‚Üí Idx‚Üì M‚Üì z) (Typ M c p , ŒΩ p))
          (Œµ : (p : Pos M c) ‚Üí Pd (Pb M (Idx‚Üì M‚Üì)) ((Typ M c p , ŒΩ p) , Œ¥ p)) where

        Œ± : alg-comp M M‚Üì i c ŒΩ
        Œ± = contr-center (is-alg i c ŒΩ)
        
        j : Idx‚Üì M‚Üì i
        j = idx Œ± 

      postulate
      
        R-lf-Œ∑‚Üì : (i : Idx M) (j : Idx‚Üì M‚Üì i)
          ‚Üí R ((((i , j) , _ , _) , (j , idp) , Œ∑‚Üì M‚Üì  j , cst idp) , lf (i , j) , ‚ä•-elim) 

        -- R-nd-Œº‚Üì : (i : Idx M) (j : Idx‚Üì M‚Üì i)
        --   ‚Üí (c : Cns M i) (ŒΩ : (p : Pos M c) ‚Üí Idx‚Üì M‚Üì (Typ M c p))
        --   ‚Üí (Œ¥ : (p : Pos M c) ‚Üí Cns‚Çö M (Œª z ‚Üí Idx‚Üì M‚Üì z) (Typ M c p , ŒΩ p))
        --   ‚Üí (Œµ : (p : Pos M c) ‚Üí Pd (Pb M (Idx‚Üì M‚Üì)) ((Typ M c p , ŒΩ p) , Œ¥ p))
        --   ‚Üí R ((((i , j) , _ , _) , (j , idp) , Œº‚Üì M‚Üì {!!} {!!} , {!!}) , nd (c , ŒΩ) Œ¥ Œµ , {!!}) 

        R-nd-Œº‚Üì : (i : Idx M) 
          ‚Üí (c : Cns M i) (ŒΩ : (p : Pos M c) ‚Üí Idx‚Üì M‚Üì (Typ M c p))
          ‚Üí (Œ¥ : (p : Pos M c) ‚Üí Cns‚Çö M (Œª z ‚Üí Idx‚Üì M‚Üì z) (Typ M c p , ŒΩ p))
          ‚Üí (Œµ : (p : Pos M c) ‚Üí Pd (Pb M (Idx‚Üì M‚Üì)) ((Typ M c p , ŒΩ p) , Œ¥ p))
          ‚Üí let Œ± = contr-center (is-alg i c ŒΩ)
                j = idx Œ±
                d = cns Œ±
                œÑ = typ Œ±
            in R ((((i , j) , _ , _) , (j , idp) , Œº‚Üì M‚Üì d {!!} , {!!}) , nd (c , ŒΩ) Œ¥ Œµ , Œª { p ‚Üí {!p!} }) 

      -- Rats.  We have that reduction problem: because it's a
      -- position in a *particular* monad, it doesn't compute
      -- correctly.  Annoying.

      -- OH!!! But because M‚Üì is algebraic, we can actually *complete*
      -- the given information to a series of constructors: just use
      -- the decoration ŒΩ and the fact that M‚Üì is an algebraic
      -- extension.  (This means replacing j with the resulting
      -- output).  Nice.  So there's no more hypotheses needed.  The
      -- rest is determined.

      -- Yep.  And so it's clear what to do: assume the constructor
      -- over and a continutation of Œ∏ for all places.  Use this to do
      -- the multiplication over, and then reassemble the Œ∏ argument
      -- from the local data and the assumed continuation.

      need-to-show : (i : Idx Slc‚ÇÇ) ‚Üí R i ‚Üí CanonRel‚ÇÇ i
      need-to-show ((((i , j) , ._ , ._) , (.j , idp) , d , typ-d=ŒΩ) , lf .(i , j) , Œ∏) r =
        (((j , idp) , Œ∑‚Üì M‚Üì j , cst idp) , {!!}) , lf‚Üì (j , idp) , Œª { () }

        -- Okay, and so this is clear from the fact that we have r in
        -- the context: by the fundamental theorem, this element of r
        -- is equivalent to the required equality.
        
      need-to-show ((((i , j) , ._ , ._) , (.j , idp) , d , typ-d=ŒΩ) , nd (c , ŒΩ) Œ¥ Œµ , Œ∏) r = 
        (((j , idp) , {!!} , {!!}) , {!!}) , {!nd‚Üì (d , typ-d=ŒΩ) ? ?!} , {!!}


      -- It occurs to me that this direction may be more informative ...
      other-way : (i : Idx Slc‚ÇÇ) ‚Üí CanonRel‚ÇÇ i ‚Üí R i
      -- other-way ((((i , j) , c , ŒΩ) , (.j , idp) , (d , typ-d=ŒΩ)) , œâ , Œ∏) ((_ , idp) , (A , B)) = {!œâ!}
      other-way ((((i , j) , ._ , ._) , (.j , idp) , d , typ-d=ŒΩ) , lf .(i , j) , Œ∏) ((_ , idp) , A , B) = {!!}

        -- I see. So the point now is to use this elimination
        -- principle which reduces us to this case: we'll transform
        -- the canonical element using the fact that the extension is
        -- algebraic to obtain the element of R.
        where my-alg : alg-comp M M‚Üì i (Œ∑ M i) (cst j)
              my-alg = ‚ü¶ j ‚à£ Œ∑‚Üì M‚Üì j ‚à£ idp ‚üß 

              competitor : alg-comp M M‚Üì i (Œ∑ M i) (cst j)
              competitor = ‚ü¶ j ‚à£ d ‚à£ (Œª= typ-d=ŒΩ) ‚üß
              
              pth : my-alg == competitor
              pth = contr-has-all-paths ‚¶É is-alg i (Œ∑ M i) (cst j) ‚¶Ñ my-alg competitor 

              -- Right, so funext is going to make this annoying like it was before.
              -- Probably this is an indication that you should modify the definition
              -- of algebraic....

              -- I see.  But you do in fact match on this data in the proof of the
              -- algebricity theorem.  So it's clearly a tradeoff......

      other-way ((((i , j) , ._ , ._) , (.j , idp) , d , typ-d=ŒΩ) , nd (c , ŒΩ) Œ¥ Œµ , Œ∏) ((_ , idp) , A , B) = {!A!}

        -- Okay, I don't see what this one is, but it should be the
        -- second blank that you let agda fill in for you above.  So I
        -- think it's clearly there.  And you're just going to have
        -- the same strategy: reduce to this case by contractibility,
        -- and that's going to be the hypothesis from above.

        -- Right, so it looks like you'll have to actually modify
        -- delta and whatnot which complicates things a bit.  But
        -- I think I'm starting to see the idea.
        
        where the-alg : alg-comp M M‚Üì i (Œº M c (fst ‚àò Œ¥)) (Œª p ‚Üí snd (Œ¥ (Œº-pos-fst M c (fst ‚àò Œ¥) p)) (Œº-pos-snd M c (fst ‚àò Œ¥) p))
              the-alg = ‚ü¶ fst (fst (Œ∏ (inl tt))) ‚à£ Œº‚Üì M‚Üì (fst (snd (Œ∏ true))) {!!}  ‚à£ {!!} ‚üß 

      --
      -- CanonRel ((((i , j) , (c , ŒΩ)) , ((j , idp) , (d , typ-d=ŒΩ))) , (œâ , Œ∏)) reduces to:
      -- 
      -- Œ£
      -- (Œ£
      --  (Œ£ (Œ£ (Idx‚Üì M‚Üì i) (Œª j‚ÇÅ ‚Üí j‚ÇÅ == j))
      --   (Œª i‚Üì ‚Üí
      --      Œ£ (Cns‚Üì M‚Üì (fst i‚Üì) c)
      --      (Œª d‚ÇÅ ‚Üí (p : Pos M c) ‚Üí Typ‚Üì M‚Üì d‚ÇÅ p == ŒΩ p)))
      --  (Œª j‚ÇÅ ‚Üí j‚ÇÅ == (j , idp) , d , typ-d=ŒΩ))
      -- (Œª i‚Üì ‚Üí
      --    Œ£
      --    (Pd‚Üì (Pb‚Üì M‚Üì (Idx‚Üì M‚Üì) (Œª i‚ÇÅ ‚Üí _==_)) (fst (fst i‚Üì) , snd (fst i‚Üì))
      --     œâ)
      --    (Œª d‚ÇÅ ‚Üí
      --       (p : Pos‚Çõ (Pb M (Idx‚Üì M‚Üì)) œâ) ‚Üí
      --       Typ‚Üì‚Çõ (Pb‚Üì M‚Üì (Idx‚Üì M‚Üì) (Œª i‚ÇÅ ‚Üí _==_)) d‚ÇÅ p == Œ∏ p))

      
