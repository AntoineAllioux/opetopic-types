{-# OPTIONS --without-K --rewriting #-}

open import HoTT
open import Monad
open import MonadOver
open import Pb
open import OpetopicType

module Lemmas where

  -- Just going to accumulate random lemmas that clog the typechecker
  -- here so that we can use them in what follows...

  rotate : ∀ {ℓ} {A : Type ℓ} {a₀ a₁ a₂ : A}
    → (p : a₀ == a₁) (q : a₂ == a₁) (r : a₀ == a₂)
    → p ∙ ! q == r
    → p == r ∙ q
  rotate idp idp r s = s ∙ ! (∙-unit-r r)

  pth-alg₀ : ∀ {ℓ} {A : Set ℓ} {a₀ a₁ a₂ : A}
    → (p : a₀ == a₁) (q : a₂ == a₁) 
    → p == (p ∙ ! q) ∙ q 
  pth-alg₀ idp idp = idp

  pth-alg₁ : ∀ {ℓ} {A : Set ℓ} {a₀ a₁ a₂ : A}
    → (p : a₀ == a₂) (q : a₁ == a₀) 
    → p == (! q ∙ idp) ∙ q ∙ p
  pth-alg₁ idp idp = idp 

  -- Lemma about transporting in constructors
  typ-trans-inv : (M : 𝕄) (M↓ : 𝕄↓ M)
    → {i : Idx M} {c : Cns M i}
    → {j j' : Idx↓ M↓ i} (e : j == j')
    → (d : Cns↓ M↓ j c) (p : Pos M c)
    → Typ↓ M↓ (transport (λ x → Cns↓ M↓ x c) e d) p == Typ↓ M↓ d p
  typ-trans-inv M M↓ idp d p = idp

  fst=-comm : ∀ {i j} {A : Type i} {B : A → Type j}
    → {x y z : Σ A B} (p : y == x) (q : y == z)
    → fst= (! p ∙ q) == ! (fst= p) ∙ fst= q
  fst=-comm idp idp = idp

  --
  -- Various generic lemmas about indices and so on in the slice
  -- generated by a monad over ....
  --
  
  module SliceOver (M : 𝕄) (M↓ : 𝕄↓ M) where

    Plbk : 𝕄
    Plbk = Pb M (Idx↓ M↓)

    Plbk↓ : 𝕄↓ Plbk
    Plbk↓ = Pb↓ M↓ (Idx↓ M↓) (λ i j k → j == k)
    
    Slc : 𝕄
    Slc = Slice Plbk

    Slc↓ : 𝕄↓ Slc
    Slc↓ = Slice↓ Plbk↓
  
    -- An explicit description of equalities in Idx↓ Slc↓ 
    slc-idx-lem : (i : Idx M) (j : Idx↓ M↓ i)
      → (c : Cns M i) (ν : (p : Pos M c) → Idx↓ M↓ (Typ M c p))
      → {j₀ : Idx↓ M↓ i} {e₀ : j₀ == j}
      → {d₀ : Cns↓ M↓ j₀ c} {α₀ : (p : Pos M c) → Typ↓ M↓ d₀ p == ν p}
      → {j₁ : Idx↓ M↓ i} {e₁ : j₁ == j}
      → {d₁ : Cns↓ M↓ j₁ c} {α₁ : (p : Pos M c) → Typ↓ M↓ d₁ p == ν p}
      → (q : j₀ == j₁) (r : e₀ == q ∙ e₁)
      → (s : transport (λ x → Cns↓ M↓ x c) q d₀ == d₁)
      → (t : (p : Pos M c) → α₀ p == (! (typ-trans-inv M M↓ q d₀ p) ∙ ap (λ x → Typ↓ M↓ x p) s) ∙ α₁ p)
      → Path {A = Idx↓ Slc↓ ((i , j) , c , ν)}
        ((j₀ , e₀) , (d₀ , α₀)) ((j₁ , e₁) , (d₁ , α₁)) 
    slc-idx-lem i j c ν idp idp idp t =
      pair= idp (pair= idp (λ= t))

    slc-idx-lem-coh : (i : Idx M) (j : Idx↓ M↓ i)
      → (c : Cns M i) (ν : (p : Pos M c) → Idx↓ M↓ (Typ M c p))
      → {j₀ : Idx↓ M↓ i} {e₀ : j₀ == j}
      → {d₀ : Cns↓ M↓ j₀ c} {α₀ : (p : Pos M c) → Typ↓ M↓ d₀ p == ν p}
      → {j₁ : Idx↓ M↓ i} {e₁ : j₁ == j}
      → {d₁ : Cns↓ M↓ j₁ c} {α₁ : (p : Pos M c) → Typ↓ M↓ d₁ p == ν p}
      → (q : j₀ == j₁) (r : e₀ == q ∙ e₁)
      → (s : transport (λ x → Cns↓ M↓ x c) q d₀ == d₁)
      → (t : (p : Pos M c) → α₀ p == (! (typ-trans-inv M M↓ q d₀ p) ∙ ap (λ x → Typ↓ M↓ x p) s) ∙ α₁ p)
      → fst= (slc-idx-lem i j c ν q r s t) == pair= q (↓-idf=cst-in r)
    slc-idx-lem-coh i j c ν idp idp idp t = fst=-β idp (pair= idp (λ= t)) 

    postulate
      ↓-Pb-out : {i : Idx Plbk} {c : Cns Plbk i}
        → {j₀ j₁ : Idx↓ Plbk↓ i} {e : j₀ == j₁}
        → {d₀ : Cns↓ Plbk↓ j₀ c} {d₁ : Cns↓ Plbk↓ j₁ c}
        → (r : d₀ == d₁ [ (λ x → Cns↓ (Pb↓ M↓ (Idx↓ M↓) (λ i j k → j == k)) x c) ↓ e ])
        → (p : Pos Plbk {f = i} c) → snd d₀ p == (! (typ-trans-inv M M↓ (fst= e) (fst d₀) p) ∙
             ap (λ x → Typ↓ M↓ x p) (to-transp (↓-ap-in (λ z → Cns↓ M↓ z (fst c)) fst (↓-Σ-fst r)))) ∙ snd d₁ p
    -- ↓-Pb-out i c j₀ j₁ e d₀ d₁ = {!!}

