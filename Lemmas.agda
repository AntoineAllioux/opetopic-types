{-# OPTIONS --without-K --rewriting #-}

open import HoTT
open import Monad
open import MonadOver
open import Pb
open import OpetopicType

module Lemmas where

  -- Just going to accumulate random lemmas that clog the typechecker
  -- here so that we can use them in what follows...

  rotate : ∀ {ℓ} {A : Type ℓ} {a₀ a₁ a₂ : A}
    → (p : a₀ == a₁) (q : a₂ == a₁) (r : a₀ == a₂)
    → p ∙ ! q == r
    → p == r ∙ q
  rotate idp idp r s = s ∙ ! (∙-unit-r r)

  pth-alg₀ : ∀ {ℓ} {A : Set ℓ} {a₀ a₁ a₂ : A}
    → (p : a₀ == a₁) (q : a₂ == a₁) 
    → p == (p ∙ ! q) ∙ q 
  pth-alg₀ idp idp = idp

  pth-alg₁ : ∀ {ℓ} {A : Set ℓ} {a₀ a₁ a₂ : A}
    → (p : a₀ == a₂) (q : a₁ == a₀) 
    → p == (! q ∙ idp) ∙ q ∙ p
  pth-alg₁ idp idp = idp 

  -- Lemma about transporting in constructors
  typ-trans-inv : (M : 𝕄) (M↓ : 𝕄↓ M)
    → {i : Idx M} {c : Cns M i}
    → {j j' : Idx↓ M↓ i} (e : j == j')
    → (d : Cns↓ M↓ j c) (p : Pos M c)
    → Typ↓ M↓ (transport (λ x → Cns↓ M↓ x c) e d) p == Typ↓ M↓ d p
  typ-trans-inv M M↓ idp d p = idp

  fst=-comm : ∀ {i j} {A : Type i} {B : A → Type j}
    → {x y z : Σ A B} (p : y == x) (q : y == z)
    → fst= (! p ∙ q) == ! (fst= p) ∙ fst= q
  fst=-comm idp idp = idp

  Σ-fst-triv-lem₀ : ∀ {i j} {A : Type i} {B : A → Type j}
    → {a : A} {b₀ b₁ : B a} (p : Path {A = Σ A B} (a , b₀) (a , b₁))
    → (q : fst= p == idp)
    → b₀ == b₁
  Σ-fst-triv-lem₀ {B = B} {b₀ = b₀} {b₁ = b₁} p q =
    transport (λ x → b₀ == b₁ [ B ↓ x ]) q (snd= p) 
  
  Σ-fst-triv-lem₁ : ∀ {i j k} {A : Type i} {B : A → Type j}
    → {C : Σ A B → Type k}
    → {a : A} {b₀ b₁ : B a} (p : (a , b₀) == (a , b₁))
    → (q : fst= p == idp)
    → {x : C (a , b₀)} {y : C (a , b₁)}
    → x == y [ C ↓ p ]
    → x == y [ (λ b → C (a , b)) ↓ Σ-fst-triv-lem₀ p q ] 
  Σ-fst-triv-lem₁ {B = B} {C = C} {a = a} {b₀ = b₀} {b₁ = b₁} p q {x} {y} r =
    ↓-ap-out C (a ,_) (Σ-fst-triv-lem₀ p q) (transport (λ z → x == y [ C ↓ z ]) pth r)

    where pth : p == pair= idp (Σ-fst-triv-lem₀ p q)
          pth = pair=-η p ∙ (ap (λ z → pair= (fst z) (snd z))
            (pair= q (from-transp (λ z → b₀ == b₁ [ B ↓ z ]) q {u = snd= p} idp)))

  --
  -- Various generic lemmas about indices and so on in the slice
  -- generated by a monad over ....
  --
  
  module SliceOver (M : 𝕄) (M↓ : 𝕄↓ M) where

    Plbk : 𝕄
    Plbk = Pb M (Idx↓ M↓)

    Plbk↓ : 𝕄↓ Plbk
    Plbk↓ = Pb↓ M↓ (Idx↓ M↓) (λ i j k → j == k)
    
    Slc : 𝕄
    Slc = Slice Plbk

    Slc↓ : 𝕄↓ Slc
    Slc↓ = Slice↓ Plbk↓
  
    -- An explicit description of equalities in Idx↓ Slc↓ 
    slc-idx-lem : (i : Idx M) (j : Idx↓ M↓ i)
      → (c : Cns M i) (ν : (p : Pos M c) → Idx↓ M↓ (Typ M c p))
      → {j₀ : Idx↓ M↓ i} {e₀ : j₀ == j}
      → {d₀ : Cns↓ M↓ j₀ c} {α₀ : (p : Pos M c) → Typ↓ M↓ d₀ p == ν p}
      → {j₁ : Idx↓ M↓ i} {e₁ : j₁ == j}
      → {d₁ : Cns↓ M↓ j₁ c} {α₁ : (p : Pos M c) → Typ↓ M↓ d₁ p == ν p}
      → (q : j₀ == j₁) (r : e₀ == q ∙ e₁)
      → (s : transport (λ x → Cns↓ M↓ x c) q d₀ == d₁)
      → (t : (p : Pos M c) → α₀ p == (! (typ-trans-inv M M↓ q d₀ p) ∙ ap (λ x → Typ↓ M↓ x p) s) ∙ α₁ p)
      → Path {A = Idx↓ Slc↓ ((i , j) , c , ν)}
        ((j₀ , e₀) , (d₀ , α₀)) ((j₁ , e₁) , (d₁ , α₁)) 
    slc-idx-lem i j c ν idp idp idp t =
      pair= idp (pair= idp (λ= t))

    slc-idx-lem-coh : (i : Idx M) (j : Idx↓ M↓ i)
      → (c : Cns M i) (ν : (p : Pos M c) → Idx↓ M↓ (Typ M c p))
      → {j₀ : Idx↓ M↓ i} {e₀ : j₀ == j}
      → {d₀ : Cns↓ M↓ j₀ c} {α₀ : (p : Pos M c) → Typ↓ M↓ d₀ p == ν p}
      → {j₁ : Idx↓ M↓ i} {e₁ : j₁ == j}
      → {d₁ : Cns↓ M↓ j₁ c} {α₁ : (p : Pos M c) → Typ↓ M↓ d₁ p == ν p}
      → (q : j₀ == j₁) (r : e₀ == q ∙ e₁)
      → (s : transport (λ x → Cns↓ M↓ x c) q d₀ == d₁)
      → (t : (p : Pos M c) → α₀ p == (! (typ-trans-inv M M↓ q d₀ p) ∙ ap (λ x → Typ↓ M↓ x p) s) ∙ α₁ p)
      → fst= (slc-idx-lem i j c ν q r s t) == pair= q (↓-idf=cst-in r)
    slc-idx-lem-coh i j c ν idp idp idp t = fst=-β idp (pair= idp (λ= t)) 

    -- A version with path overs ... could this simplify some things?
    slc-idx-lem↓ : (i : Idx M) (j : Idx↓ M↓ i)
      → (c : Cns M i) (ν : (p : Pos M c) → Idx↓ M↓ (Typ M c p))
      → {j₀ : Idx↓ M↓ i} {e₀ : j₀ == j}
      → {d₀ : Cns↓ M↓ j₀ c} {α₀ : (p : Pos M c) → Typ↓ M↓ d₀ p == ν p}
      → {j₁ : Idx↓ M↓ i} {e₁ : j₁ == j}
      → {d₁ : Cns↓ M↓ j₁ c} {α₁ : (p : Pos M c) → Typ↓ M↓ d₁ p == ν p}
      → (q : j₀ == j₁) (r : e₀ == q ∙ e₁)
      → (s : d₀ == d₁ [ (λ x → Cns↓ M↓ x c) ↓ q ])
      → (t : (p : Pos M c) → α₀ p == ap (λ x → Typ↓ M↓ (snd x) p) (pair= q s) ∙ α₁ p)
      → Path {A = Idx↓ Slc↓ ((i , j) , c , ν)}
        ((j₀ , e₀) , (d₀ , α₀)) ((j₁ , e₁) , (d₁ , α₁)) 
    slc-idx-lem↓ i j c ν {j₀} {e₀} {d₀} {α₀ = α₀} {α₁ = α₁} idp idp idp t =
      ap (λ x → ((j₀ , e₀) , d₀ , x)) (λ= t)

    module Helpers (i : Idx M) (j : Idx↓ M↓ i)
             (c : Cns M i) (ν : (p : Pos M c) → Idx↓ M↓ (Typ M c p))
             (δ : (p : Pos M c) → Cns Plbk (Typ M c p , ν p))
             (ε : (p : Pos M c) → Cns Slc ((Typ M c p , ν p) , δ p))
             (d : Cns↓ M↓ j c) (typ-d=ν : (p : Pos M c) → Typ↓ M↓ d p == ν p) where

      μf = μ-pos-fst M c (fst ∘ δ)
      μs = μ-pos-snd M c (fst ∘ δ)

      δμ : (pq : Pos M (μ M c (fst ∘ δ)))
        → Idx↓ M↓ (Typ M (fst (δ (μf pq))) (μs pq))
      δμ pq = snd (δ (μf pq)) (μs pq) 

      δ↓μ : (δ↓ : (p : Pos M c) → Cns↓ Plbk↓ (Typ↓ M↓ d p , typ-d=ν p) (δ p))
        → (pq : Pos M (μ M c (fst ∘ δ)))
        → Typ↓ M↓ (fst (δ↓ (μf pq))) (μs pq)
        == snd (δ (μf pq)) (μs pq)
      δ↓μ δ↓ pq = snd (δ↓ (μf pq)) (μs pq) 

      module _ (δ↓₀ δ↓₁ : (p : Pos M c) → Cns↓ Plbk↓ (Typ↓ M↓ d p , typ-d=ν p) (δ p))
               (δ-eq : (p : Pos M c) → δ↓₀ p == δ↓₁ p) where

        pb-pth : Path {A = Cns↓ Plbk↓ (j , idp) (μ M c (fst ∘ δ) , δμ)}
                    (μ↓ M↓ d (fst ∘ δ↓₀) , δ↓μ δ↓₀)
                    (μ↓ M↓ d (fst ∘ δ↓₁) , δ↓μ δ↓₁)
        pb-pth = ap (λ x → μ↓ M↓ d (fst ∘ x) , δ↓μ x) (λ= δ-eq)

        module _ (ε↓₀ : (p : Pos M c) → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , δ↓₀ p) (ε p))
                 (ε↓₁ : (p : Pos M c) → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , δ↓₁ p) (ε p))
                 (ε-eq : (p : Pos M c) → ε↓₀ p == ε↓₁ p [ (λ x → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , x) (ε p)) ↓ δ-eq p ]) where

          Dom : Set 
          Dom = Σ ((p : Pos M c) → Cns↓ Plbk↓ (Typ↓ M↓ d p , typ-d=ν p) (δ p))
                (λ δ↓ → (p : Pos M c) → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , δ↓ p) (ε p))

          Map : (dm : Dom) → Cns↓ Slc↓ ((j , idp) , (μ↓ M↓ d (fst ∘ fst dm) , δ↓μ (fst dm))) (nd (c , ν) δ ε)
          Map (δ⇣ , ε⇣) =  nd↓ {f↓ = j , idp} (d , typ-d=ν) δ⇣ ε⇣



          something : ε↓₀ == ε↓₁ [ (λ x → (p : Pos M c) → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , x p) (ε p)) ↓ λ= δ-eq ]
          something = ↓-Π-cst-app-in (λ p → ↓-ap-out
                                              {A = (r : Pos M c) → Cns↓ Plbk↓ (Typ↓ M↓ d r , typ-d=ν r) (δ r)}
                                              (λ x → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , x) (ε p)) (λ x → x p)
                                              (λ= δ-eq) (transport (λ z → ε↓₀ p == ε↓₁ p [ (λ x → Cns↓ Slc↓ ((Typ↓ M↓ d p , typ-d=ν p) , x) (ε p)) ↓ z ])
                                              (! (app=-β δ-eq p)) (ε-eq p)))

          pth : Path {A = Dom} (δ↓₀ , ε↓₀) (δ↓₁ , ε↓₁)
          pth = pair= (λ= δ-eq) something

          can-get : nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                    == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                      [ (λ x → Cns↓ Slc↓ ((j , idp) , (μ↓ M↓ d (fst ∘ (fst x)) , δ↓μ (fst x))) (nd (c , ν) δ ε)) ↓ pth ]
          can-get = apd Map pth 

          hence : nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                    == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                      [ (λ x → Cns↓ Slc↓ ((j , idp) , (μ↓ M↓ d (fst ∘ x) , δ↓μ x)) (nd (c , ν) δ ε)) ↓ ap fst pth ]
          hence = ↓-ap-in (λ x → Cns↓ Slc↓ ((j , idp) , (μ↓ M↓ d (fst ∘ x) , δ↓μ x)) (nd (c , ν) δ ε)) fst can-get 

          need : nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                  [ (λ x → Cns↓ Slc↓ ((j , idp) , (μ↓ M↓ d (fst ∘ x) , δ↓μ x)) (nd (c , ν) δ ε)) ↓ λ= δ-eq ]
          need = transport (λ z → nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                    == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                      [ (λ x → Cns↓ Slc↓ ((j , idp) , (μ↓ M↓ d (fst ∘ x) , δ↓μ x)) (nd (c , ν) δ ε)) ↓ z ]) (fst=-β (λ= δ-eq) something) hence 

          first :  nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                     [ (λ x → Cns↓ Slc↓ ((j , idp) , x) (nd (c , ν) δ ε)) ↓ pb-pth ]
          first = ↓-ap-in (λ x → Cns↓ Slc↓ ((j , idp) , x) (nd (c , ν) δ ε)) (λ x → μ↓ M↓ d (fst ∘ x) , δ↓μ x)
                  need

          and-ive-got : nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                     [ (λ x → Cns↓ Slc↓ x (nd (c , ν) δ ε)) ↓ ap (λ x → (j , idp) , x) pb-pth ]
          and-ive-got = ↓-ap-in (λ x → Cns↓ Slc↓ x (nd (c , ν) δ ε)) (λ x → (j , idp) , x)
                          first 

          -- Okay, now we'd like to get this last lemma
          claim :  nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                     [ (λ x → Cns↓ Slc↓ x (nd (c , ν) δ ε)) ↓ pair= idp pb-pth ]
          claim = transport (λ z → nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₀ ε↓₀
                == nd↓ {f↓ = j , idp} (d , typ-d=ν) δ↓₁ ε↓₁
                     [ (λ x → Cns↓ Slc↓ x (nd (c , ν) δ ε)) ↓ z ]) idp and-ive-got


-- ap↓ : ∀ {i j k} {A : Type i} {B : A → Type j} {C : A → Type k}
--   (g : {a : A} → B a → C a) {x y : A} {p : x == y}
--   {u : B x} {v : B y}
--   → (u == v [ B ↓ p ] → g u == g v [ C ↓ p ])
-- ap↓ g {p = idp} p = ap g p

-- apd↓ : ∀ {i j k} {A : Type i} {B : A → Type j} {C : (a : A) → B a → Type k}
--   (f : {a : A} (b : B a) → C a b) {x y : A} {p : x == y}
--   {u : B x} {v : B y} (q : u == v [ B ↓ p ])
--   → f u == f v [ (λ xy → C (fst xy) (snd xy)) ↓ pair= p q ]
-- apd↓ f {p = idp} idp = idp

  -- ↓-Π-cst-app-in : {x x' : A} {p : x == x'}
  --   {u : (b : B) → C x b} {u' : (b : B) → C x' b}
  --   → ((b : B) → u b == u' b [ (λ x → C x b) ↓ p ])
  --   → (u == u' [ (λ x → (b : B) → C x b) ↓ p ])
  -- ↓-Π-cst-app-in {p = idp} f = λ= f

  -- ↓-Π-in : {x x' : A} {p : x == x'} {u : Π (B x) (C x)} {u' : Π (B x') (C x')}
  --   → ({t : B x} {t' : B x'} (q : t == t' [ B ↓ p ])
  --       → u t == u' t' [ uncurry C ↓ pair= p q ])
  --   → (u == u' [ (λ x → Π (B x) (C x)) ↓ p ])
  -- ↓-Π-in {p = idp} f = λ= (λ x → f (idp {a = x}))
